#+TITLE: ε-prolog - Prolog Engine in Emacs Lisp
#+AUTHOR: Masaya Taniguchi

* Overview

ε-prolog (~eprolog~) is a complete Prolog engine implementation written in pure Emacs Lisp. It provides a fully functional Prolog system integrated into the Emacs environment, offering traditional Prolog programming capabilities with seamless Lisp interoperability.

* Features

** Core Prolog Engine
- Complete unification algorithm with occurs check
- Backtracking and choice points with proper cut (!) semantics
- Clause database management for facts and rules
- Interactive query execution with solution enumeration

** Built-in Predicates
- Unification: ~=~, ~==~
- Type checking: ~atom/1~, ~atomic/1~, ~var/1~, ~ground/1~, ~number/1~, ~string/1~
- Control: ~fail/0~, ~!/0~, ~true/0~, ~false/0~, ~not/1~
- Logical operators: ~and/1-4~, ~or/1-4~, ~if/2-3~
- List operations: ~member/2~, ~append/2-3~, ~maplist/2-5~
- Meta-call: ~call/1+~
- Arithmetic: ~is/2~ which is an alias of ~lisp/2+~
- Lisp integration: ~lisp/2+~, ~lisp!/1+~, ~lispp/1+~

** Advanced Features
- Definite Clause Grammar (DCG) support
- Spy/debugging functionality for tracing execution
- Dynamic parameters for Prolog-Lisp state sharing
- Anonymous variable handling
- Variable renaming for clause application

* Installation

Place =eprolog.el= in your Emacs load path and add to your configuration:

#+BEGIN_SRC emacs-lisp
(require 'eprolog)
#+END_SRC

* Quick Start

ε-prolog provides convenient aliases for commonly used functions:
- =eprolog-define-predicate= for =eprolog-define-prolog-predicate=
- =eprolog-define-predicate!= for =eprolog-define-prolog-predicate!=

** Defining Facts and Rules

#+BEGIN_SRC emacs-lisp
;; Define facts (using convenient alias)
(eprolog-define-predicate (parent tom bob))
(eprolog-define-predicate (parent tom liz))
(eprolog-define-predicate (parent bob ann))
(eprolog-define-predicate (parent bob pat))
(eprolog-define-predicate (parent pat jim))

;; Define rules
(eprolog-define-predicate (grandparent _x _z)
  (parent _x _y)
  (parent _y _z))

;; Query the database
(eprolog-query (grandparent tom _x))
;; Returns: _x = ann, _x = pat
#+END_SRC

** Using Built-in Predicates

#+BEGIN_SRC emacs-lisp
;; List operations
(eprolog-query (member _x (a b c)))
;; Returns: _x = a, _x = b, _x = c

;; Append lists
(eprolog-query (append (1 2) (3 4) _result))
;; Returns: _result = (1 2 3 4)

;; Type checking
(eprolog-query (atom foo))  ; Succeeds
(eprolog-query (var _x))    ; Succeeds
(eprolog-query (number 42)) ; Succeeds
#+END_SRC

** Lisp Integration

#+BEGIN_SRC emacs-lisp
;; Call Lisp code from Prolog
(eprolog-query (lisp _result (+ 1 2 3)))
;; Returns: _result = 6

;; Use Lisp predicates
(eprolog-query (lispp (> 5 3)))  ; Succeeds
(eprolog-query (lispp (< 5 3)))  ; Fails

;; Side effects with lisp!
(eprolog-query (lisp! (message "Hello from Prolog!")))
#+END_SRC

** Definite Clause Grammars (DCG)

ε-prolog provides full support for Definite Clause Grammars (DCG), a convenient notation for parsing and generating language structures. DCGs are automatically transformed into standard Prolog predicates using difference lists for efficient parsing.

*** Basic Grammar Definition

#+BEGIN_SRC emacs-lisp
;; Define a simple grammar for sentences
(eprolog-define-grammar! s np vp)           ; sentence → noun phrase + verb phrase
(eprolog-define-grammar! np det noun)       ; noun phrase → determiner + noun  
(eprolog-define-grammar! vp verb np)        ; verb phrase → verb + noun phrase

;; Define terminals (strings represent literal words)
(eprolog-define-grammar! det "the")
(eprolog-define-grammar det "a")            ; Multiple rules for same non-terminal
(eprolog-define-grammar! noun "cat")
(eprolog-define-grammar noun "dog")
(eprolog-define-grammar! verb "chases")
(eprolog-define-grammar verb "sees")
#+END_SRC

*** Parsing with DCG

#+BEGIN_SRC emacs-lisp
;; Parse complete sentences
(eprolog-query (phrase s ("the" "cat" "chases" "a" "dog")))
;; Succeeds - valid sentence

(eprolog-query (phrase s ("a" "dog" "sees" "the" "cat")))  
;; Succeeds - another valid sentence

(eprolog-query (phrase s ("cat" "the" "chases")))
;; Fails - invalid sentence structure

;; Parse with remaining tokens
(eprolog-query (phrase s ("the" "cat" "chases" "a" "dog" "quickly") _rest))
;; _rest = ("quickly") - parses sentence, leaves remainder
#+END_SRC

*** Advanced DCG Features

**** Empty Productions (Epsilon)
#+BEGIN_SRC emacs-lisp
;; Optional adjective in noun phrases
(eprolog-define-grammar! np det noun)
(eprolog-define-grammar np det adj noun)    ; With adjective
(eprolog-define-grammar np det noun)        ; Without adjective (alternative)

;; Or using epsilon (nil) for optional elements
(eprolog-define-grammar! optional-adj nil)         ; Empty production
(eprolog-define-grammar optional-adj adj)          ; Or an adjective
(eprolog-define-grammar! np det optional-adj noun)

(eprolog-define-grammar! adj "big")
(eprolog-define-grammar adj "small")
#+END_SRC

**** Semantic Actions
#+BEGIN_SRC emacs-lisp
;; Grammar with semantic constraints using (@ goal...)
(eprolog-define-grammar! (np _number) (det _number) (noun _number))
(eprolog-define-grammar! (det singular) "a")
(eprolog-define-grammar! (det plural) "some") 
(eprolog-define-grammar! (noun singular) "cat")
(eprolog-define-grammar! (noun plural) "cats")

;; Sentence with number agreement
(eprolog-define-grammar! (s _num) (np _num) (vp _num))
(eprolog-define-grammar! (vp _num) (verb _num) (np _))
(eprolog-define-grammar! (verb singular) "chases")
(eprolog-define-grammar! (verb plural) "chase")

;; Parse with number agreement checking
(eprolog-query (phrase s ("a" "cat" "chases" "some" "cats")))
;; Succeeds - number agreement maintained

(eprolog-query (phrase s ("a" "cat" "chase" "some" "cats")))  
;; Fails - number disagreement
#+END_SRC

**** Cut in DCG Rules
#+BEGIN_SRC emacs-lisp
;; Deterministic parsing with cut
(eprolog-define-grammar! statement declarative !)
(eprolog-define-grammar statement question)

(eprolog-define-grammar! declarative s ".")
(eprolog-define-grammar! question s "?")

;; First match commits due to cut
(eprolog-query (phrase statement ("the" "cat" "chases" "a" "dog" ".")))
;; Succeeds, won't try question alternative
#+END_SRC

*** List Processing with DCG

#+BEGIN_SRC emacs-lisp
;; Parse sequences (like comma-separated values)
(eprolog-define-grammar! csv-list item)
(eprolog-define-grammar csv-list item "," csv-list)

(eprolog-define-grammar! item "apple")
(eprolog-define-grammar item "banana") 
(eprolog-define-grammar item "cherry")

;; Parse CSV-style lists
(eprolog-query (phrase csv-list ("apple" "," "banana" "," "cherry")))
;; Succeeds

;; Parse numbers in sequence
(eprolog-define-grammar! number-seq number)
(eprolog-define-grammar number-seq number number-seq)

(eprolog-define-grammar! number "1")
(eprolog-define-grammar number "2") 
(eprolog-define-grammar number "3")
(eprolog-define-grammar number "4")
(eprolog-define-grammar number "5")

(eprolog-query (phrase number-seq ("1" "2" "3" "4" "5")))
;; Succeeds - parses sequence of number strings
#+END_SRC

*** Grammar Generation

DCGs can generate sentences as well as parse them:

#+BEGIN_SRC emacs-lisp
;; Generate all possible sentences
(eprolog-query (phrase s _sentence))
;; _sentence = ("the" "cat" "chases" "the" "cat")
;; _sentence = ("the" "cat" "chases" "the" "dog")  
;; _sentence = ("the" "cat" "chases" "a" "cat")
;; ... (continues with all valid combinations)

;; Generate sentences of specific length
(eprolog-define-predicate (length () 0))
(eprolog-define-predicate (length (_h . _t) _n)
  (length _t _n1)
  (is _n (+ _n1 1)))

(eprolog-query (phrase s _sentence) (length _sentence 5))
;; Generates only 5-word sentences
#+END_SRC

*** Complex Grammar Examples

**** Arithmetic Expressions
#+BEGIN_SRC emacs-lisp
;; Grammar for simple arithmetic
(eprolog-define-grammar! expr term)
(eprolog-define-grammar expr term "+" expr)
(eprolog-define-grammar expr term "-" expr)

(eprolog-define-grammar! term factor)  
(eprolog-define-grammar term factor "*" term)
(eprolog-define-grammar term factor "/" term)

(eprolog-define-grammar! factor number)
(eprolog-define-grammar factor "(" expr ")")

(eprolog-define-grammar! number "1")
(eprolog-define-grammar number "2")
(eprolog-define-grammar number "3")
(eprolog-define-grammar number "4")

;; Parse arithmetic expressions
(eprolog-query (phrase expr ("2" "+" "3" "*" "4")))
;; Succeeds - parses "2 + 3 * 4"
#+END_SRC

**** Nested Structures  
#+BEGIN_SRC emacs-lisp
;; Grammar for nested parentheses
(eprolog-define-grammar! parens nil)                    ; Empty
(eprolog-define-grammar parens "(" parens ")" parens)   ; Nested

;; Check balanced parentheses
(eprolog-query (phrase parens ("(" "(" ")" "(" ")" ")")))
;; Succeeds - balanced

(eprolog-query (phrase parens ("(" "(" ")" ")")))  
;; Fails - unbalanced
#+END_SRC

* API Reference

** Predicate Definition

*** eprolog-define-prolog-predicate
Define a Prolog clause (fact or rule) and add it to the database.

#+BEGIN_SRC emacs-lisp
(eprolog-define-prolog-predicate (name arg1 arg2 ...) goal1 goal2 ...)
#+END_SRC

The first argument is a head term containing the predicate name and its arguments. For facts with no arguments, you can omit the parentheses: =(eprolog-define-prolog-predicate name)=.

*Alias:* =eprolog-define-predicate=

*** eprolog-define-prolog-predicate!
Define a Prolog clause, replacing existing clauses with the same arity.

#+BEGIN_SRC emacs-lisp
(eprolog-define-prolog-predicate! (name arg1 arg2 ...) goal1 goal2 ...)
#+END_SRC

The first argument is a head term containing the predicate name and its arguments. For facts with no arguments, you can omit the parentheses: =(eprolog-define-prolog-predicate! name)=.

*Alias:* =eprolog-define-predicate!=

*** eprolog-define-lisp-predicate
Define a predicate implemented in Emacs Lisp.

#+BEGIN_SRC emacs-lisp
(eprolog-define-lisp-predicate name (arg1 arg2 ...)
  ;; Lisp code returning success or failure object
  )
#+END_SRC

** Query Execution

*** eprolog-query
Execute an interactive Prolog query.

#+BEGIN_SRC emacs-lisp
(eprolog-query goal1 goal2 ...)
#+END_SRC

*** eprolog-solve
Programmatically solve goals with optional keyword callbacks.

#+BEGIN_SRC emacs-lisp
;; Basic usage - just solve goals, ignore results
(eprolog-solve goals)

;; With success callback only
(eprolog-solve goals :success (lambda (bindings) ...))

;; With both callbacks
(eprolog-solve goals 
  :success (lambda (bindings) ...)
  :failure (lambda () ...))
#+END_SRC

** DCG Support

*** eprolog-define-grammar
Define a DCG rule, adding to existing rules with the same arity.

#+BEGIN_SRC emacs-lisp
(eprolog-define-grammar head body-element1 body-element2 ...)
#+END_SRC

Adds a new DCG rule without replacing existing ones. This allows multiple alternatives for the same non-terminal.

**** DCG Element Types:
- =string= - Terminal symbols (literal strings to match)
- =symbol= - Non-terminal symbols (other DCG rules) 
- =(symbol args...)= - Non-terminals with arguments
- =nil= - Epsilon production (empty, consumes no input)
- =! - Cut operator (prevents backtracking)
- =(@ goal...)= - Semantic actions (constraints that don't consume input)

**** Examples:
#+BEGIN_SRC emacs-lisp
(eprolog-define-grammar noun "cat")           ; Terminal rule
(eprolog-define-grammar noun "dog")           ; Alternative terminal
(eprolog-define-grammar s np vp)              ; Non-terminal rule
(eprolog-define-grammar (s _num) (np _num) (vp _num))  ; With arguments
(eprolog-define-grammar optional nil)         ; Epsilon production
(eprolog-define-grammar checked-noun (@ (atom _n)) noun)  ; Semantic action
#+END_SRC

*** eprolog-define-grammar!
Define a DCG rule, replacing existing rules with the same arity.

#+BEGIN_SRC emacs-lisp
(eprolog-define-grammar! head body-element1 body-element2 ...)
#+END_SRC

Similar to =eprolog-define-grammar= but removes existing rules for the same non-terminal with the same arity before adding the new rule. Used for redefinition or when you want only one rule for a non-terminal.

**** Examples:
#+BEGIN_SRC emacs-lisp
(eprolog-define-grammar! s np vp)             ; Replace any existing s/0 rules
(eprolog-define-grammar! (det _num) "the")    ; Replace det/1 rules
#+END_SRC

*** phrase/2 and phrase/3
Parse or generate using DCG rules.

#+BEGIN_SRC emacs-lisp
;; Parse complete input
(eprolog-query (phrase non-terminal input-list))

;; Parse with remainder  
(eprolog-query (phrase non-terminal input-list remainder))
#+END_SRC

=phrase/2= succeeds if the non-terminal can parse the entire input list.
=phrase/3= succeeds if the non-terminal can parse a prefix, with the remainder unified with the third argument.

**** Examples:
#+BEGIN_SRC emacs-lisp
(eprolog-query (phrase s ("the" "cat" "runs")))
;; Succeeds if s can parse the complete sentence

(eprolog-query (phrase np ("the" "big" "cat" "runs" "fast") _rest))  
;; _rest = ("runs" "fast") if np parses "the big cat"
#+END_SRC

*** DCG Best Practices

**** Left Recursion
Avoid left recursion in DCG rules as it can cause infinite loops:

#+BEGIN_SRC emacs-lisp
;; BAD - left recursive
(eprolog-define-grammar expr expr "+" term)

;; GOOD - right recursive  
(eprolog-define-grammar expr term "+" expr)
(eprolog-define-grammar expr term)
#+END_SRC

**** Deterministic Parsing
Use cut (!) to make parsing deterministic when appropriate:

#+BEGIN_SRC emacs-lisp
(eprolog-define-grammar! statement declarative-stmt !)
(eprolog-define-grammar statement question-stmt)
#+END_SRC

**** Semantic Constraints
Use semantic actions (@ ...) for constraints that don't consume input:

#+BEGIN_SRC emacs-lisp
;; Ensure number agreement
(eprolog-define-grammar (s _num) 
  (np _num) 
  (@ (atom _num))           ; Constraint: _num must be bound
  (vp _num))
#+END_SRC

* Testing

ε-prolog includes a comprehensive test suite in =eprolog-test.el= with 51 tests covering all major functionality.

** Running Tests

*** Command Line (Recommended)
Run all tests from the command line using Emacs batch mode:

#+BEGIN_SRC bash
emacs -batch -l eprolog.el -l eprolog-test.el -f ert-run-tests-batch-and-exit
#+END_SRC

*** Interactive Testing
Run tests interactively within Emacs:

#+BEGIN_SRC emacs-lisp
;; Load the test file
(load-file "eprolog-test.el")

;; Run all tests interactively
(ert-run-tests-interactively t)

;; Run a specific test
(ert-run-tests-interactively "eprolog-test-fibonacci-with-lispp")

;; Run tests matching a pattern
(ert-run-tests-interactively "family-tree")
#+END_SRC

* Debugging

Enable spy mode to trace predicate execution:

#+BEGIN_SRC emacs-lisp
;; Add predicates to spy list
(setq eprolog-spy-predicates '(grandparent parent))

;; Set spy mode
(setq eprolog-spy-state 'prompt) ; or 'always or 'disabled

;; Run query with tracing
(eprolog-query (grandparent tom _x))
#+END_SRC

* Implementation Details

ε-prolog implements a complete Prolog engine with:

- Unification: Standard unification algorithm with optional occurs check
- Proof Search: Depth-first search with backtracking via continuations
- Cut Implementation: Proper cut semantics using exception handling
- Variable Scoping: Automatic variable renaming for clause application
- Success/Failure Types: Explicit representation of computation results

The engine uses continuation-passing style for backtracking, making the implementation both elegant and efficient within Emacs Lisp's constraints.

* License

ε-prolog is released under the GNU General Public License v3.0. See LICENSE.org for details.

* Historical Note

This implementation has an interesting lineage.
It originally derives from Peter Norvig's Prolog implementation in [[https://github.com/norvig/paip-lisp][Paradigms of Artificial Intelligence Programming]] ([[https://github.com/norvig/paip-lisp/blob/9cea73837e439d331fe78d7b585e994c7113aac2/LICENSE][MIT licensed]]).
The code was first reimplemented in Scheme as [[https://github.com/tani/athena][Athena]], then ported back to Common Lisp,
and finally adapted for Emacs Lisp as ε-prolog.
Each iteration refined the implementation while maintaining the core algorithmic elegance of the original.

* Contributing

Contributions are welcome! Please feel free to submit issues and pull requests.

* Author

Masaya Taniguchi

* Acknowledgments

This implementation draws inspiration from classical Prolog systems and modern functional programming techniques, adapted specifically for the Emacs Lisp environment.
